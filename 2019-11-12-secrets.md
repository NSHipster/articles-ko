---
title: iOS가 비밀을 지키는 방식
author: Mattt
translator: 김필권
category: Miscellaneous
excerpt: >-
  _"민감한 정보를 기기에 안전하게 저장하는 방법"_은 iOS 개발의 난제 중 하나라고 생각합니다.
status:
  swift: 5.1
---

_"민감한 정보를 기기에 안전하게 저장하는 방법"_은 iOS 개발의 난제 중 하나라고 생각합니다.

실제로 충분한 조치를 취하지 않은 경우엔 GitHub같은 소스 컨트롤을 통해서, 앱스토어에 배포된 `.ipa` 파일을 분석하는 도구를 통해서 등의 방법으로 앱의 중요한 정보들이 유출될 수 있습니다.

때론 크레덴셜 보안은 후순위로 밀릴 때도 있지만, 여기 우선 순위를 올리는 것을 진지하게 고민해보셔야 하는 이유가 있습니다.

North Carolina State University의 연구원들이 [발견한 내용](https://www.ndss-symposium.org/ndss-paper/how-bad-can-it-git-characterizing-secret-leakage-in-public-github-repositories/)에 따르면, API Key, 이중 인증 정보를 포함하는 민감한 정보들이 하루에도 수 천 개씩 GitHub에서 유출되고 있다고 합니다.
{% cite meli_2019 %}
[2018년에 발표된 내용](https://ieeexplore.ieee.org/abstract/document/8719525/authors#authors)에 따르면, 인기있는 100개의 샘플 앱 중 68개가 SDK 크레덴셜이 제대로 설정돼있지 않았다고 합니다.
{% cite wen_2018 %}

이번 글에선 [조금 오래된 밈](https://knowyourmeme.com/memes/galaxy-brain)을 이용해서 민감한 정보를 보호하는 작업을 점진적으로 진행해보겠습니다.

만약 여러분 앱에 Twitter 액세스 토큰, Stripe API Key, AWS Key ID 등 민감한 정보가 많다면 꼭 읽으시는 것을 추천드립니다!

<hr/>

## <small>🧠 하수</small> 소스 코드에 민감한 정보를 하드코딩함

인증을 위해서 비밀인 API 키를 통해 웹 어플리케이션과 통신해야하는 앱이 있다고 해보겠습니다.
그렇다면 인증 코드는 써드 파티 프레임워크로 빼거나 `AppDelegate`에 `URLSession`을 구현해서 작업했을 것입니다.
어떤 경우든 API 키를 어떻게, 어디에 저장하는지가 문제일 것입니다.

코드에 스트링 리터럴로 추가하는 것은 어떨까요?

```swift
enum Secrets {
    static let apiKey = "6a0f0731d84afa4082031e3a72354991"
}
```

그리고 앱 배포를 위해 아카이브하면 당연히 코드에 있던 '사람이 읽을 수 있는' 텍스트가 '기계만 읽을 수 있는' 바이너리로 바뀌니 문제가 없을 것입니다. 물론 아무런 보안 문제 없이요... _그렇죠_?

_그닥요._

[Radare2](https://rada.re)같은 리버스 엔지니어링 도구가 있다면 컴파일된 결과물일지라도 읽을 수 있는 형태로 만들어줍니다.
이는 실제 프로젝트에서 "Generic iOS Device"를 선택한 후 아카이브한(Product > Archive) 결과(`.xcarchive`)로도 증명이 가능합니다.

```terminal
$ r2 ~/Developer/Xcode/Archives/<#...#>.xcarchive/Products/Applications/Swordfish.app/Swordfish
[0x1000051fc]> iz
[Strings]
Num Paddr      Vaddr      Len Size Section  Type  String
000 0x00005fa0 0x100005fa0  30  31 (3.__TEXT.__cstring) ascii _TtC9Swordfish14ViewController
001 0x00005fc7 0x100005fc7  13  14 (3.__TEXT.__cstring) ascii @32@0:8@16@24
002 0x00005fe0 0x100005fe0  36  37 (3.__TEXT.__cstring) ascii 6a0f0731d84afa4082031e3a72354991
<#...#>
```

앱 스토어를 사용하는 보통의 사용자라면 당연히 `.ipa` 파일을 열어볼 생각조차 하지 않겠지만, 보안 및 통계 목적으로 앱의 페이로드를 분석하는 개인이나 단체가 분명 존재할 것입니다.
게다가 그런 회사에는 하드코딩된 크레덴셜을 솎아내는 봇도 있을 것입니다.

제가 말씀드린 것 중 일부는 추측이지만 확실한 것도 있습니다.

소스 코드에 민감한 정보를 하드코딩하면 그것들은 소스 컨트롤에 영원히 살게 될 것입니다.
그리고 그것은 저장소 설정을 잘못 설정하거나 데이터가 유출됐을 경우 모든 것이 공개될 가능성으로 이어집니다.
사람과 사람이 하는 일에서 이런 일이 일어나지 않을 거란 확신은 할 수 없습니다.

조심해서 나쁠 것은 없다고 생각합니다.

{% error %}

소스 코드에 민감한 정보를 커밋하지 마세요.

{% enderror %}

> 적에게서 나의 비밀을 지키고 싶다면, 친구에게도 그 비밀을 말하지 말라.

벤자민 프랭클린이 했던 말입니다.

## <small>🧠 중수</small> Xcode 설정과 Info.plist에 저장함

[이전 글](https://nshipster.com/xcconfig/)에선 [12-Factor App이 말하는 좋은 예제](https://12factor.net/config)를 보며 `.xcconfig` 파일을 사용하는 방법에 대해 얘기했었습니다.
게다가 `Info.plist`를 통해 구체화한다면 이러한 빌드 설정은 그럭저럭 괜찮은 [`.env` 파일](https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/osmanagement/env_file.html) 역할을 할 것입니다.

```
// Development.xcconfig
API_KEY = 6a0f0731d84afa4082031e3a72354991

// Release.xcconfig
API_KEY = d9b3c5d63229688e4ddbeff6e1a04a49
```

이 파일이 소스 컨트롤에 올라가지만 않는다면 이러한 접근 방식은 민감한 정보가 유출되는 문제를 해결할 수 있을 것입니다.
그리고 딱 봤을 때 우리가 걱정했던 유출 문제를 해결할 수 있을 것처럼 보입니다.

실제로 <em lang="en-leet">l33t hax0r</em> 도구를 통해 검색해보면 아무 결과도 나오지 않습니다. (`izz`는 스트링 바이너리의 목록을 보여주는 명령어이고, `~6a0f07`는 민감한 정보의 앞 몇 글자만 따서 가져온 것입니다.)

```terminal
$ r2 ~/Developer/Xcode/Archives/<#...#>.xcarchive/Products/Applications/Swordfish.app/Swordfish
[0x100005040]> izz~6a0f
[0x100005040]>
```

축배를 들기 전에, 앱 페이로드를 확인해봅시다.

```terminal
$ tree <#...#>/Swordfish.app
├── Base.lproj
│   ├── LaunchScreen.storyboardc
│   │   ├── 01J-lp-oVM-view-Ze5-6b-2t3.nib
│   │   ├── Info.plist
│   │   └── UIViewController-01J-lp-oVM.nib
│   └── Main.storyboardc
│       ├── BYZ-38-t0r-view-8bC-Xf-vdC.nib
│       ├── Info.plist
│       └── UIViewController-BYZ-38-t0r.nib
├── Info.plist
├── PkgInfo
├── Swordfish
├── _CodeSignature
│   └── CodeResources
└── embedded.mobileprovision
```

`Info.plist` 파일은 우리가 민감한 정보를 담았던 파일이 아닌가요?
맞습니다. 실행 파일 옆에 잘 패키징돼있네요.

여러 측면에서 봤을 때, 이 방법은 코드에 민감한 정보를 하드코딩하는 것보다 _덜_ 안전한 것으로 추측됩니다.
왜냐하면 아무런 작업 없이 페이로드에서 비밀에 바로 접근이 가능하기 때문입니다.

```terminal
$ plutil -p <#...#>/Swordfish.app/Info.plist
{
  "API_KEY" => "6a0f0731d84afa4082031e3a72354991"
<#...#>
```

<hr/>

사용자가 기기에서 앱을 실행했을 때 환경을 설정하는 방법은 존재하지 않습니다.
그래서 앞에 얘기한 것처럼 `Info.plist`를 정보 교환소로 사용해서 빌드 세팅을 바꾸려고 하는 것은 의미없다는 것입니다.

하지만 분명 환경을 코드에서 캡쳐할 수 있는 다른 방법이 있지 않을까요...

## <small>🧠 고수</small> 코드 생성을 통해 민감한 정보를 난독화

A while back,
we wrote about [<dfn>GYB</dfn>](/swift-gyb/),
a code generation tool used in the Swift standard library.
Although that article focuses on eliminating boilerplate code,
GYB's metaprogramming capabilities go far beyond that.

For example,
we can use GYB to pull environment variables into generated code:

```terminal
$ API_KEY=6a0f0731d84afa4082031e3a72354991 \
gyb --line-directive '' <<"EOF"
%{ import os }%
let apiKey = "${os.environ.get('API_KEY')}"
EOF

let apiKey = "6a0f0731d84afa4082031e3a72354991"
```

Generating _(and not committing)_ Swift files from GYB while
pulling secrets from environment variables
solves the problem of leaking credentials in source code,
but it fails to guard against common static analysis tools.
However,
we can use a combination of Swift and Python code (via GYB)
to obfuscate secrets in a way that's more difficult to reverse-engineer.

For example, here's an (admittedly crude) solution
that implements an <abbr>XOR</abbr> cipher
using a salt that's generated randomly each time:

```swift
// Secrets.swift.gyb
%{
import os

def chunks(seq, size):
    return (seq[i:(i + size)] for i in range(0, len(seq), size))

def encode(string, cipher):
    bytes = string.encode("UTF-8")
    return [ord(bytes[i]) ^ cipher[i % len(cipher)] for i in range(0, len(bytes))]
}%
enum Secrets {
    private static let salt: [UInt8] = [
    %{ salt = [ord(byte) for byte in os.urandom(64)] }%
    % for chunk in chunks(salt, 8):
        ${"".join(["0x%02x, " % byte for byte in chunk])}
    % end
    ]

    static var apiKey: String {
        let encoded: [UInt8] = [
        % for chunk in chunks(encode(os.environ.get('API_KEY'), salt), 8):
            ${"".join(["0x%02x, " % byte for byte in chunk])}
        % end
        ]

        return decode(encoded, salt: cipher)
    }

    <#...#>
}
```

Secrets are pulled from the environment and encoded by a Python function
before being included in the source code as `[UInt8]` array literals.
Those encoded values are then run through an equivalent Swift function
to retrieve the original value
without exposing any secrets directly in the source.

The resulting code looks something like this:

```swift
// Secrets.swift
enum Secrets {
    private static let salt: [UInt8] = [
        0xa2, 0x00, 0xcf, <#...#>, 0x06, 0x84, 0x1c,
    ]

    static var apiKey: String {
        let encoded: [UInt8] = [
            0x94, 0x61, 0xff, <#...#> 0x15, 0x05, 0x59,
        ]

        return decode(encoded, cipher: salt)
    }

    static func decode(_ encoded: [UInt8], cipher: [UInt8]) -> String {
        String(decoding: encoded.enumerated().map { (offset, element) in
            element ^ cipher[offset % cipher.count]
        }, as: UTF8.self)
    }
}

Secrets.apiKey // "6a0f0731d84afa4082031e3a72354991"
```

{% info %}

If you're using [CocoaPods](/cocoapods/),
you might be interested in the
[CocoaPods Keys plugin](https://github.com/orta/cocoapods-keys),
which also encodes secrets with code generation
(albeit without any obfuscation).

{% endinfo %}

While [security through obscurity](https://en.wikipedia.org/wiki/Security_through_obscurity)
may be theoretically unsound,
[it can be an effective solution in practice](https://ieeexplore.ieee.org/abstract/document/8449256).
{% cite wang_2018 %}

As the old saying goes:

> You don’t have to outrun a bear to be safe.
> You just have to outrun the guy next to you.

## <small>🧠 초고수</small> Don't Store Secrets On-Device

No matter how much we obfuscate a secret on the client,
it's only a matter of time before the secret gets out.
Given enough time and sufficient motivation,
an attacker will be able to reverse-engineer
whatever you throw their way.

The only _true_ way to keep secrets in mobile apps
is to store them on the server.

Following this tack,
our imagined plot shifts from an _Oceans 11_-style heist movie
to a high-stakes _Behind Enemy Lines_ escort mission movie.
_(Your mission:
Transfer a payload from the server
and store it in the
[Secure Enclave](https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/storing_keys_in_the_secure_enclave)
without an attacker compromising it.)_

If you don't have a server that you can trust,
there are a few Apple services that can serve as a transport mechanism:

- [On-Demand Resources](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/index.html):
  Download a [data asset](/nsdataasset/) containing a plain-text secret.
- [CloudKit Database](https://developer.apple.com/documentation/cloudkitjs/cloudkit/database):
  Set secrets in a private database in your CloudKit Dashboard.
  _(Bonus: Subscribe to changes for automatic credential rolling functionality)_
- [Background Updates](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app):
  Push secrets silently to clients as soon as they come online via
  [APNS](/apns-device-tokens/).

Then again,
once your secret reaches the Secure Enclave,
it'll be sent right back out with the next outbound request
for which it's used.
It's not enough to get it right once;
security is a practice.

Or put another way:

> A secret in Secure Enclave is safe,
> but that is not what secrets are for.

## <small>🧠 신</small> Client Secrecy is Impossible

There's no way to secure secrets stored on the client.
Once someone can run your software on their own device,
it's game over.

And maintaining a secure, closed communications channel between client and server
incurs an immense amount of operational complexity ---
assuming it's possible in the first place.

Perhaps Julian Assange said it best:

> The only way to keep a secret is to never have one.

<hr/>

**Rather than looking at client secret management as a problem to be solved,
we should see it instead as an anti-pattern to be avoided.**

What is an `API_KEY` other than an insecure, anonymous authentication mechanism, anyway?
It's a blank check that anyone can cash,
a persistent liability the operational integrity of your business.

Any third-party SDK that's configured with a client secret is insecure by design.
If your app uses any SDKs that fits this description,
you should see if it's possible to move the integration to the server.
Barring that,
you should take time to understand the impact of a potential leak
and consider whether you're willing to accept that risk.
If you deem the risk to be substantial,
it wouldn't be a bad idea to look into ways to obfuscate sensitive information
to reduce the likelihood of exposure.

<hr/>

Restating our original question:
_"How do I store secrets securely on the client?"_

Our answer:
_"Don't (but if you must, obfuscation wouldn't hurt)."_

<hr/>

<footer id="bibliography">

<h5>References</h5>

{% bibliography --cited %}

</footer>
