---
title: iOSê°€ ë¹„ë°€ì„ ì§€í‚¤ëŠ” ë°©ì‹
author: Mattt
translator: ê¹€í•„ê¶Œ
category: Miscellaneous
excerpt: >-
  _"ë¯¼ê°í•œ ì •ë³´ë¥¼ ê¸°ê¸°ì— ì•ˆì „í•˜ê²Œ ì €ì¥í•˜ëŠ” ë°©ë²•"_ì€ iOS ê°œë°œì˜ ë‚œì œ ì¤‘ í•˜ë‚˜ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.
status:
  swift: 5.1
---

_"ë¯¼ê°í•œ ì •ë³´ë¥¼ ê¸°ê¸°ì— ì•ˆì „í•˜ê²Œ ì €ì¥í•˜ëŠ” ë°©ë²•"_ì€ iOS ê°œë°œì˜ ë‚œì œ ì¤‘ í•˜ë‚˜ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.

ì‹¤ì œë¡œ ì¶©ë¶„í•œ ì¡°ì¹˜ë¥¼ ì·¨í•˜ì§€ ì•Šì€ ê²½ìš°ì—” GitHubê°™ì€ ì†ŒìŠ¤ ì»¨íŠ¸ë¡¤ì„ í†µí•´ì„œ, ì•±ìŠ¤í† ì–´ì— ë°°í¬ëœ `.ipa` íŒŒì¼ì„ ë¶„ì„í•˜ëŠ” ë„êµ¬ë¥¼ í†µí•´ì„œ ë“±ì˜ ë°©ë²•ìœ¼ë¡œ ì•±ì˜ ì¤‘ìš”í•œ ì •ë³´ë“¤ì´ ìœ ì¶œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë•Œë¡  í¬ë ˆë´ì…œ ë³´ì•ˆì€ í›„ìˆœìœ„ë¡œ ë°€ë¦´ ë•Œë„ ìˆì§€ë§Œ, ì—¬ê¸° ìš°ì„  ìˆœìœ„ë¥¼ ì˜¬ë¦¬ëŠ” ê²ƒì„ ì§„ì§€í•˜ê²Œ ê³ ë¯¼í•´ë³´ì…”ì•¼ í•˜ëŠ” ì´ìœ ê°€ ìˆìŠµë‹ˆë‹¤.

North Carolina State Universityì˜ ì—°êµ¬ì›ë“¤ì´ [ë°œê²¬í•œ ë‚´ìš©](https://www.ndss-symposium.org/ndss-paper/how-bad-can-it-git-characterizing-secret-leakage-in-public-github-repositories/)ì— ë”°ë¥´ë©´, API Key, ì´ì¤‘ ì¸ì¦ ì •ë³´ë¥¼ í¬í•¨í•˜ëŠ” ë¯¼ê°í•œ ì •ë³´ë“¤ì´ í•˜ë£¨ì—ë„ ìˆ˜ ì²œ ê°œì”© GitHubì—ì„œ ìœ ì¶œë˜ê³  ìˆë‹¤ê³  í•©ë‹ˆë‹¤.
{% cite meli_2019 %}
[2018ë…„ì— ë°œí‘œëœ ë‚´ìš©](https://ieeexplore.ieee.org/abstract/document/8719525/authors#authors)ì— ë”°ë¥´ë©´, ì¸ê¸°ìˆëŠ” 100ê°œì˜ ìƒ˜í”Œ ì•± ì¤‘ 68ê°œê°€ SDK í¬ë ˆë´ì…œì´ ì œëŒ€ë¡œ ì„¤ì •ë¼ìˆì§€ ì•Šì•˜ë‹¤ê³  í•©ë‹ˆë‹¤.
{% cite wen_2018 %}

ì´ë²ˆ ê¸€ì—ì„  [ì¡°ê¸ˆ ì˜¤ë˜ëœ ë°ˆ](https://knowyourmeme.com/memes/galaxy-brain)ì„ ì´ìš©í•´ì„œ ë¯¼ê°í•œ ì •ë³´ë¥¼ ë³´í˜¸í•˜ëŠ” ì‘ì—…ì„ ì ì§„ì ìœ¼ë¡œ ì§„í–‰í•´ë³´ê² ìŠµë‹ˆë‹¤.

ë§Œì•½ ì—¬ëŸ¬ë¶„ ì•±ì— Twitter ì•¡ì„¸ìŠ¤ í† í°, Stripe API Key, AWS Key ID ë“± ë¯¼ê°í•œ ì •ë³´ê°€ ë§ë‹¤ë©´ ê¼­ ì½ìœ¼ì‹œëŠ” ê²ƒì„ ì¶”ì²œë“œë¦½ë‹ˆë‹¤!

<hr/>

## <small>ğŸ§  í•˜ìˆ˜</small> ì†ŒìŠ¤ ì½”ë“œì— ë¯¼ê°í•œ ì •ë³´ë¥¼ í•˜ë“œì½”ë”©í•¨

ì¸ì¦ì„ ìœ„í•´ì„œ ë¹„ë°€ì¸ API í‚¤ë¥¼ í†µí•´ ì›¹ ì–´í”Œë¦¬ì¼€ì´ì…˜ê³¼ í†µì‹ í•´ì•¼í•˜ëŠ” ì•±ì´ ìˆë‹¤ê³  í•´ë³´ê² ìŠµë‹ˆë‹¤.
ê·¸ë ‡ë‹¤ë©´ ì¸ì¦ ì½”ë“œëŠ” ì¨ë“œ íŒŒí‹° í”„ë ˆì„ì›Œí¬ë¡œ ë¹¼ê±°ë‚˜ `AppDelegate`ì— `URLSession`ì„ êµ¬í˜„í•´ì„œ ì‘ì—…í–ˆì„ ê²ƒì…ë‹ˆë‹¤.
ì–´ë–¤ ê²½ìš°ë“  API í‚¤ë¥¼ ì–´ë–»ê²Œ, ì–´ë””ì— ì €ì¥í•˜ëŠ”ì§€ê°€ ë¬¸ì œì¼ ê²ƒì…ë‹ˆë‹¤.

ì½”ë“œì— ìŠ¤íŠ¸ë§ ë¦¬í„°ëŸ´ë¡œ ì¶”ê°€í•˜ëŠ” ê²ƒì€ ì–´ë–¨ê¹Œìš”?

```swift
enum Secrets {
    static let apiKey = "6a0f0731d84afa4082031e3a72354991"
}
```

ê·¸ë¦¬ê³  ì•± ë°°í¬ë¥¼ ìœ„í•´ ì•„ì¹´ì´ë¸Œí•˜ë©´ ë‹¹ì—°íˆ ì½”ë“œì— ìˆë˜ 'ì‚¬ëŒì´ ì½ì„ ìˆ˜ ìˆëŠ”' í…ìŠ¤íŠ¸ê°€ 'ê¸°ê³„ë§Œ ì½ì„ ìˆ˜ ìˆëŠ”' ë°”ì´ë„ˆë¦¬ë¡œ ë°”ë€Œë‹ˆ ë¬¸ì œê°€ ì—†ì„ ê²ƒì…ë‹ˆë‹¤. ë¬¼ë¡  ì•„ë¬´ëŸ° ë³´ì•ˆ ë¬¸ì œ ì—†ì´ìš”... _ê·¸ë ‡ì£ _?

_ê·¸ë‹¥ìš”._

[Radare2](https://rada.re)ê°™ì€ ë¦¬ë²„ìŠ¤ ì—”ì§€ë‹ˆì–´ë§ ë„êµ¬ê°€ ìˆë‹¤ë©´ ì»´íŒŒì¼ëœ ê²°ê³¼ë¬¼ì¼ì§€ë¼ë„ ì½ì„ ìˆ˜ ìˆëŠ” í˜•íƒœë¡œ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.
ì´ëŠ” ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œ "Generic iOS Device"ë¥¼ ì„ íƒí•œ í›„ ì•„ì¹´ì´ë¸Œí•œ(Product > Archive) ê²°ê³¼(`.xcarchive`)ë¡œë„ ì¦ëª…ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```terminal
$ r2 ~/Developer/Xcode/Archives/<#...#>.xcarchive/Products/Applications/Swordfish.app/Swordfish
[0x1000051fc]> iz
[Strings]
Num Paddr      Vaddr      Len Size Section  Type  String
000 0x00005fa0 0x100005fa0  30  31 (3.__TEXT.__cstring) ascii _TtC9Swordfish14ViewController
001 0x00005fc7 0x100005fc7  13  14 (3.__TEXT.__cstring) ascii @32@0:8@16@24
002 0x00005fe0 0x100005fe0  36  37 (3.__TEXT.__cstring) ascii 6a0f0731d84afa4082031e3a72354991
<#...#>
```

ì•± ìŠ¤í† ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ë³´í†µì˜ ì‚¬ìš©ìë¼ë©´ ë‹¹ì—°íˆ `.ipa` íŒŒì¼ì„ ì—´ì–´ë³¼ ìƒê°ì¡°ì°¨ í•˜ì§€ ì•Šê² ì§€ë§Œ, ë³´ì•ˆ ë° í†µê³„ ëª©ì ìœ¼ë¡œ ì•±ì˜ í˜ì´ë¡œë“œë¥¼ ë¶„ì„í•˜ëŠ” ê°œì¸ì´ë‚˜ ë‹¨ì²´ê°€ ë¶„ëª… ì¡´ì¬í•  ê²ƒì…ë‹ˆë‹¤.
ê²Œë‹¤ê°€ ê·¸ëŸ° íšŒì‚¬ì—ëŠ” í•˜ë“œì½”ë”©ëœ í¬ë ˆë´ì…œì„ ì†ì•„ë‚´ëŠ” ë´‡ë„ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

ì œê°€ ë§ì”€ë“œë¦° ê²ƒ ì¤‘ ì¼ë¶€ëŠ” ì¶”ì¸¡ì´ì§€ë§Œ í™•ì‹¤í•œ ê²ƒë„ ìˆìŠµë‹ˆë‹¤.

ì†ŒìŠ¤ ì½”ë“œì— ë¯¼ê°í•œ ì •ë³´ë¥¼ í•˜ë“œì½”ë”©í•˜ë©´ ê·¸ê²ƒë“¤ì€ ì†ŒìŠ¤ ì»¨íŠ¸ë¡¤ì— ì˜ì›íˆ ì‚´ê²Œ ë  ê²ƒì…ë‹ˆë‹¤.
ê·¸ë¦¬ê³  ê·¸ê²ƒì€ ì €ì¥ì†Œ ì„¤ì •ì„ ì˜ëª» ì„¤ì •í•˜ê±°ë‚˜ ë°ì´í„°ê°€ ìœ ì¶œëì„ ê²½ìš° ëª¨ë“  ê²ƒì´ ê³µê°œë  ê°€ëŠ¥ì„±ìœ¼ë¡œ ì´ì–´ì§‘ë‹ˆë‹¤.
ì‚¬ëŒê³¼ ì‚¬ëŒì´ í•˜ëŠ” ì¼ì—ì„œ ì´ëŸ° ì¼ì´ ì¼ì–´ë‚˜ì§€ ì•Šì„ ê±°ë€ í™•ì‹ ì€ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

ì¡°ì‹¬í•´ì„œ ë‚˜ì  ê²ƒì€ ì—†ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.

{% error %}

ì†ŒìŠ¤ ì½”ë“œì— ë¯¼ê°í•œ ì •ë³´ë¥¼ ì»¤ë°‹í•˜ì§€ ë§ˆì„¸ìš”.

{% enderror %}

> ì ì—ê²Œì„œ ë‚˜ì˜ ë¹„ë°€ì„ ì§€í‚¤ê³  ì‹¶ë‹¤ë©´, ì¹œêµ¬ì—ê²Œë„ ê·¸ ë¹„ë°€ì„ ë§í•˜ì§€ ë§ë¼.

ë²¤ìë¯¼ í”„ë­í´ë¦°ì´ í–ˆë˜ ë§ì…ë‹ˆë‹¤.

## <small>ğŸ§  ì¤‘ìˆ˜</small> Xcode ì„¤ì •ê³¼ Info.plistì— ì €ì¥í•¨

[ì´ì „ ê¸€](https://nshipster.com/xcconfig/)ì—ì„  [12-Factor Appì´ ë§í•˜ëŠ” ì¢‹ì€ ì˜ˆì œ](https://12factor.net/config)ë¥¼ ë³´ë©° `.xcconfig` íŒŒì¼ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ì–˜ê¸°í–ˆì—ˆìŠµë‹ˆë‹¤.
ê²Œë‹¤ê°€ `Info.plist`ë¥¼ í†µí•´ êµ¬ì²´í™”í•œë‹¤ë©´ ì´ëŸ¬í•œ ë¹Œë“œ ì„¤ì •ì€ ê·¸ëŸ­ì €ëŸ­ ê´œì°®ì€ [`.env` íŒŒì¼](https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/osmanagement/env_file.html) ì—­í• ì„ í•  ê²ƒì…ë‹ˆë‹¤.

```
// Development.xcconfig
API_KEY = 6a0f0731d84afa4082031e3a72354991

// Release.xcconfig
API_KEY = d9b3c5d63229688e4ddbeff6e1a04a49
```

ì´ íŒŒì¼ì´ ì†ŒìŠ¤ ì»¨íŠ¸ë¡¤ì— ì˜¬ë¼ê°€ì§€ë§Œ ì•ŠëŠ”ë‹¤ë©´ ì´ëŸ¬í•œ ì ‘ê·¼ ë°©ì‹ì€ ë¯¼ê°í•œ ì •ë³´ê°€ ìœ ì¶œë˜ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.
ê·¸ë¦¬ê³  ë”± ë´¤ì„ ë•Œ ìš°ë¦¬ê°€ ê±±ì •í–ˆë˜ ìœ ì¶œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì„ ê²ƒì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤.

ì‹¤ì œë¡œ <em lang="en-leet">l33t hax0r</em> ë„êµ¬ë¥¼ í†µí•´ ê²€ìƒ‰í•´ë³´ë©´ ì•„ë¬´ ê²°ê³¼ë„ ë‚˜ì˜¤ì§€ ì•ŠìŠµë‹ˆë‹¤. (`izz`ëŠ” ìŠ¤íŠ¸ë§ ë°”ì´ë„ˆë¦¬ì˜ ëª©ë¡ì„ ë³´ì—¬ì£¼ëŠ” ëª…ë ¹ì–´ì´ê³ , `~6a0f07`ëŠ” ë¯¼ê°í•œ ì •ë³´ì˜ ì• ëª‡ ê¸€ìë§Œ ë”°ì„œ ê°€ì ¸ì˜¨ ê²ƒì…ë‹ˆë‹¤.)

```terminal
$ r2 ~/Developer/Xcode/Archives/<#...#>.xcarchive/Products/Applications/Swordfish.app/Swordfish
[0x100005040]> izz~6a0f
[0x100005040]>
```

ì¶•ë°°ë¥¼ ë“¤ê¸° ì „ì—, ì•± í˜ì´ë¡œë“œë¥¼ í™•ì¸í•´ë´…ì‹œë‹¤.

```terminal
$ tree <#...#>/Swordfish.app
â”œâ”€â”€ Base.lproj
â”‚Â Â  â”œâ”€â”€ LaunchScreen.storyboardc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 01J-lp-oVM-view-Ze5-6b-2t3.nib
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Info.plist
â”‚Â Â  â”‚Â Â  â””â”€â”€ UIViewController-01J-lp-oVM.nib
â”‚Â Â  â””â”€â”€ Main.storyboardc
â”‚Â Â      â”œâ”€â”€ BYZ-38-t0r-view-8bC-Xf-vdC.nib
â”‚Â Â      â”œâ”€â”€ Info.plist
â”‚Â Â      â””â”€â”€ UIViewController-BYZ-38-t0r.nib
â”œâ”€â”€ Info.plist
â”œâ”€â”€ PkgInfo
â”œâ”€â”€ Swordfish
â”œâ”€â”€ _CodeSignature
â”‚Â Â  â””â”€â”€ CodeResources
â””â”€â”€ embedded.mobileprovision
```

`Info.plist` íŒŒì¼ì€ ìš°ë¦¬ê°€ ë¯¼ê°í•œ ì •ë³´ë¥¼ ë‹´ì•˜ë˜ íŒŒì¼ì´ ì•„ë‹Œê°€ìš”?
ë§ìŠµë‹ˆë‹¤. ì‹¤í–‰ íŒŒì¼ ì˜†ì— ì˜ íŒ¨í‚¤ì§•ë¼ìˆë„¤ìš”.

ì—¬ëŸ¬ ì¸¡ë©´ì—ì„œ ë´¤ì„ ë•Œ, ì´ ë°©ë²•ì€ ì½”ë“œì— ë¯¼ê°í•œ ì •ë³´ë¥¼ í•˜ë“œì½”ë”©í•˜ëŠ” ê²ƒë³´ë‹¤ _ëœ_ ì•ˆì „í•œ ê²ƒìœ¼ë¡œ ì¶”ì¸¡ë©ë‹ˆë‹¤.
ì™œëƒí•˜ë©´ ì•„ë¬´ëŸ° ì‘ì—… ì—†ì´ í˜ì´ë¡œë“œì—ì„œ ë¹„ë°€ì— ë°”ë¡œ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

```terminal
$ plutil -p <#...#>/Swordfish.app/Info.plist
{
  "API_KEY" => "6a0f0731d84afa4082031e3a72354991"
<#...#>
```

<hr/>

ì‚¬ìš©ìê°€ ê¸°ê¸°ì—ì„œ ì•±ì„ ì‹¤í–‰í–ˆì„ ë•Œ í™˜ê²½ì„ ì„¤ì •í•˜ëŠ” ë°©ë²•ì€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
ê·¸ë˜ì„œ ì•ì— ì–˜ê¸°í•œ ê²ƒì²˜ëŸ¼ `Info.plist`ë¥¼ ì •ë³´ êµí™˜ì†Œë¡œ ì‚¬ìš©í•´ì„œ ë¹Œë“œ ì„¸íŒ…ì„ ë°”ê¾¸ë ¤ê³  í•˜ëŠ” ê²ƒì€ ì˜ë¯¸ì—†ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.

í•˜ì§€ë§Œ ë¶„ëª… í™˜ê²½ì„ ì½”ë“œì—ì„œ ìº¡ì³í•  ìˆ˜ ìˆëŠ” ë‹¤ë¥¸ ë°©ë²•ì´ ìˆì§€ ì•Šì„ê¹Œìš”...

## <small>ğŸ§  ê³ ìˆ˜</small> ì½”ë“œ ìƒì„±ì„ í†µí•´ ë¯¼ê°í•œ ì •ë³´ë¥¼ ë‚œë…í™”

A while back,
we wrote about [<dfn>GYB</dfn>](/swift-gyb/),
a code generation tool used in the Swift standard library.
Although that article focuses on eliminating boilerplate code,
GYB's metaprogramming capabilities go far beyond that.

For example,
we can use GYB to pull environment variables into generated code:

```terminal
$ API_KEY=6a0f0731d84afa4082031e3a72354991 \
gyb --line-directive '' <<"EOF"
%{ import os }%
let apiKey = "${os.environ.get('API_KEY')}"
EOF

let apiKey = "6a0f0731d84afa4082031e3a72354991"
```

Generating _(and not committing)_ Swift files from GYB while
pulling secrets from environment variables
solves the problem of leaking credentials in source code,
but it fails to guard against common static analysis tools.
However,
we can use a combination of Swift and Python code (via GYB)
to obfuscate secrets in a way that's more difficult to reverse-engineer.

For example, here's an (admittedly crude) solution
that implements an <abbr>XOR</abbr> cipher
using a salt that's generated randomly each time:

```swift
// Secrets.swift.gyb
%{
import os

def chunks(seq, size):
    return (seq[i:(i + size)] for i in range(0, len(seq), size))

def encode(string, cipher):
    bytes = string.encode("UTF-8")
    return [ord(bytes[i]) ^ cipher[i % len(cipher)] for i in range(0, len(bytes))]
}%
enum Secrets {
    private static let salt: [UInt8] = [
    %{ salt = [ord(byte) for byte in os.urandom(64)] }%
    % for chunk in chunks(salt, 8):
        ${"".join(["0x%02x, " % byte for byte in chunk])}
    % end
    ]

    static var apiKey: String {
        let encoded: [UInt8] = [
        % for chunk in chunks(encode(os.environ.get('API_KEY'), salt), 8):
            ${"".join(["0x%02x, " % byte for byte in chunk])}
        % end
        ]

        return decode(encoded, salt: cipher)
    }

    <#...#>
}
```

Secrets are pulled from the environment and encoded by a Python function
before being included in the source code as `[UInt8]` array literals.
Those encoded values are then run through an equivalent Swift function
to retrieve the original value
without exposing any secrets directly in the source.

The resulting code looks something like this:

```swift
// Secrets.swift
enum Secrets {
    private static let salt: [UInt8] = [
        0xa2, 0x00, 0xcf, <#...#>, 0x06, 0x84, 0x1c,
    ]

    static var apiKey: String {
        let encoded: [UInt8] = [
            0x94, 0x61, 0xff, <#...#> 0x15, 0x05, 0x59,
        ]

        return decode(encoded, cipher: salt)
    }

    static func decode(_ encoded: [UInt8], cipher: [UInt8]) -> String {
        String(decoding: encoded.enumerated().map { (offset, element) in
            element ^ cipher[offset % cipher.count]
        }, as: UTF8.self)
    }
}

Secrets.apiKey // "6a0f0731d84afa4082031e3a72354991"
```

{% info %}

If you're using [CocoaPods](/cocoapods/),
you might be interested in the
[CocoaPods Keys plugin](https://github.com/orta/cocoapods-keys),
which also encodes secrets with code generation
(albeit without any obfuscation).

{% endinfo %}

While [security through obscurity](https://en.wikipedia.org/wiki/Security_through_obscurity)
may be theoretically unsound,
[it can be an effective solution in practice](https://ieeexplore.ieee.org/abstract/document/8449256).
{% cite wang_2018 %}

As the old saying goes:

> You donâ€™t have to outrun a bear to be safe.
> You just have to outrun the guy next to you.

## <small>ğŸ§  ì´ˆê³ ìˆ˜</small> Don't Store Secrets On-Device

No matter how much we obfuscate a secret on the client,
it's only a matter of time before the secret gets out.
Given enough time and sufficient motivation,
an attacker will be able to reverse-engineer
whatever you throw their way.

The only _true_ way to keep secrets in mobile apps
is to store them on the server.

Following this tack,
our imagined plot shifts from an _Oceans 11_-style heist movie
to a high-stakes _Behind Enemy Lines_ escort mission movie.
_(Your mission:
Transfer a payload from the server
and store it in the
[Secure Enclave](https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/storing_keys_in_the_secure_enclave)
without an attacker compromising it.)_

If you don't have a server that you can trust,
there are a few Apple services that can serve as a transport mechanism:

- [On-Demand Resources](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/index.html):
  Download a [data asset](/nsdataasset/) containing a plain-text secret.
- [CloudKit Database](https://developer.apple.com/documentation/cloudkitjs/cloudkit/database):
  Set secrets in a private database in your CloudKit Dashboard.
  _(Bonus: Subscribe to changes for automatic credential rolling functionality)_
- [Background Updates](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app):
  Push secrets silently to clients as soon as they come online via
  [APNS](/apns-device-tokens/).

Then again,
once your secret reaches the Secure Enclave,
it'll be sent right back out with the next outbound request
for which it's used.
It's not enough to get it right once;
security is a practice.

Or put another way:

> A secret in Secure Enclave is safe,
> but that is not what secrets are for.

## <small>ğŸ§  ì‹ </small> Client Secrecy is Impossible

There's no way to secure secrets stored on the client.
Once someone can run your software on their own device,
it's game over.

And maintaining a secure, closed communications channel between client and server
incurs an immense amount of operational complexity ---
assuming it's possible in the first place.

Perhaps Julian Assange said it best:

> The only way to keep a secret is to never have one.

<hr/>

**Rather than looking at client secret management as a problem to be solved,
we should see it instead as an anti-pattern to be avoided.**

What is an `API_KEY` other than an insecure, anonymous authentication mechanism, anyway?
It's a blank check that anyone can cash,
a persistent liability the operational integrity of your business.

Any third-party SDK that's configured with a client secret is insecure by design.
If your app uses any SDKs that fits this description,
you should see if it's possible to move the integration to the server.
Barring that,
you should take time to understand the impact of a potential leak
and consider whether you're willing to accept that risk.
If you deem the risk to be substantial,
it wouldn't be a bad idea to look into ways to obfuscate sensitive information
to reduce the likelihood of exposure.

<hr/>

Restating our original question:
_"How do I store secrets securely on the client?"_

Our answer:
_"Don't (but if you must, obfuscation wouldn't hurt)."_

<hr/>

<footer id="bibliography">

<h5>References</h5>

{% bibliography --cited %}

</footer>
